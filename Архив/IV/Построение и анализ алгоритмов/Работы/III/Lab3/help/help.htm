<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
      <link rel='stylesheet' href="style.css" type='text/css' />
  </head>
  
  
  <body style='background: #691A0E;'><center><table border=0 id='wrapper'>
    <tr><td colspan=2 id='headtd'>
      Лабораторная работа <span id='headdm'>№3</span>
    </td></tr>
	
<tr><td id='navtd'>	
<table border=0 width='20%'>
  <table border=0 cellpadding=1 id='restable'>
    <tr id='reshead'>
      <th><span style='font-size: 13px'><b class='canBeLong'>Навигационная панель</b><br/>
	</span></th>
    </tr>
	 <tr class='odd'><td><span class='navitem'><a href='1.htm'>Главная страница</a></span></td>
	 <tr class='odd'><td><span class='navitem'><a href='help.htm' class='current'>Алгоритм программы</a></span></td></tr>
	 <tr class='odd'><td><span class='navitem'><a href='about_graph.htm'>Работа с графом</a></span></td>
	 
	 </table>
  </td>
   </td><td id='bodytd'>	
   

<table border=0 width='100%'>
<tr><td width='100%' valign='top'>

<h1 style='padding-bottom: 14px'><center>Алгоритм работы</center></h1>
<big><big><big><big><h3>
<p>&nbsp;&nbsp;Для произвольных s, t принадлежащих V (s &ne; t) существует вершина v, такая что:</p>
<p><center><i>d(s,t) = d(s,v) + a(v,t).</i></center></p>
<p>&nbsp;&nbsp;Действительно, таким свойством обладает предпоследняя вершина произвольного кратчайшего пути из s в t. Далее мы можем найти вершину u, для которой:</p>
<p><center><i>d(s, v) = d(s, u) + a(u, v)</i></center></p>

<p>&nbsp;&nbsp;Из положительности длины всех контуров легко следует, что созданная таким образом последовательность t, u, v, . . . не содержит повторений и оканчивается вершиной s. Очевидно, что она определяет (при обращении очередности) кратчайший путь из s в t. Таким образом, мы получаем следующий алгоритм:</p>
<h1><center>Алгоритм "Нахождение кратчайшего пути".</center></h1>
<p></p>


<p>&nbsp;&nbsp;Данные:</p>
<p>&nbsp;&nbsp;1. Расстояния D[v] от фиксированной вершины s до всех остальных вершин v принадлежащих V</p>
<p>&nbsp;&nbsp;2. Фиксированная вершина t</p>
<p>&nbsp;&nbsp;3. Матрица весов ребер A[u, v], u, v принадлежат V.</p>
  
<p>&nbsp;&nbsp;Результаты:</p>
<p>&nbsp;&nbsp;1. СТЕК содержит последовательность вершин, определяющую кратчайший путь из s в t.</p>
<i>
<pre>1 begin
2 СТЕК := &empty;; СТЕК &lArr; t; v := t;
3 while v = s do
4 begin
5 u:= вершина, для которой D[v] = D[u] + A[u, v];
6 СТЕК &lArr; u;
7 v := u;
8 end
9 end
</pre></i>

<p>&nbsp;&nbsp;Пусть V,E &mdash; ориентированный граф, |V| = n, |E| = m. Если выбор вершины u в строке 5 происходит в результате просмотра всех вершин, то сложность нашего алгоритма &mdash; O(n2). Если мы просматриваем только список ПРЕДШ[v], содержащий все вершины u, такие что u &rarr; v, то в этом случае сложность будет O(m). Отметим, что в случае положительных весов ребер задача о кратчайшем пу- ти в неориентированном графе легко сводится к аналогичной задаче для некоторого ориентированного графа. С этой целью достаточно заменить каждое ребро {u, v} двумя дугами u, v и v, u, каждая с таким же весом, что и {u, v}.</p>


<p>&nbsp;&nbsp;Однако в случае неположительных весов это приводит к возникновению контуров с неположительной длиной. В данной главе мы всегда будем предполагать, что G = V,E является ориентированным графом, n = |V|, m = |E|. В целях упрощения изложения и избежания вырожденных случаев при оценке сложности алгоритмов будем принимать m = Ω(n) (т.е. n = O(m)). Это исключает ситуации, при которых &laquo;большинство&raquo; вершин изолированные. Будем предполагать также, что веса дуг запоминаются в массиве A[u, v], u, v &isin; V (A[u, v] содержит вес a(u, v))</p>


<p></p><p></p><p></p>
<p>&nbsp;&nbsp;(В. Липский. Комбинаторика для программиста. М. &laquo;Мир&raquo;, 1988).</p>

  </h3></big></big></big></big>
  </td>
  </tr>
  
  </body>
</html>

