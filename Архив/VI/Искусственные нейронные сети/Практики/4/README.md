# Практика 4, вариант 8

## Задача

Необходимо реализовать нейронную сеть вычисляющую результат заданной логической операции. Затем реализовать функции, которые будут симулировать работу построенной модели. Функции должны принимать тензор входных данных и список весов. Должно быть реализовано 2 функции:

* Функция, в которой все операции реализованы как поэлементные операции над тензорами
* Функция, в которой все операции реализованы с использованием операций над тензорами из NumPy

Для проверки корректности работы функций необходимо:

* Инициализировать модель и получить из нее веса
* Прогнать датасет через не обученную модель и реализованные 2 функции. Сравнить результат.
* Обучить модель и получить веса после обучения
* Прогнать датасет через обученную модель и реализованные 2 функции. Сравнить результат.

Выражение: **(a and c and b) xor (a or not b)**

## Решение

Для данной задачи была выбрана следующая архитектура:

* Входной слой c input_dim = 3  
* Три скрытых слоя с 16, 8 и 8 нейронами соответственно
  * На скрытых слоях будет использоваться фукнция активации relu  
* Выходной слой с 1 нейроном
  * На выходном слое будет использоваться сигмоидная фукнция

```python
model = Sequential()
model.add(Dense(16, activation='relu', input_dim=3))
model.add(Dense(8, activation='relu'))
model.add(Dense(8, activation='relu'))
model.add(Dense(1, activation='sigmoid'))
```

В задаче в качестве оптимизатора будет использоваться RMSProp, функцией потерь
бинарная кросс-энтропия, а в качестве метрики используется точность. Обучение проводится в течение 100 эпох

```python
model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['accuracy'])
H = model.fit(x, y, epochs=100, batch_size=1, verbose=0)
```

Были реализованы функции, которые симулируют работу построенной модели: `numpy_sol` и `native_sol`.

В функции `numpy_sol` реализована функция `output = act(dot(W, input) + B)` с использованием операций над тензорами из `NumPy`.

В функции `native_sol` также реализована функция `output = act(dot(W, input) + B)`, но операции реализованы как поэлементные операции над тензорами. Для этих операций были реализованы функции `naive_dot_vXm(y, x)` и `naive_dot_vXv(x, y)` для скалярных произведений тензоров и `naive_add_vXv(x, y)` для сложения тензоров.

Функция `solution` вычисляет веса и смещения слоев, а также выводит результаты.

## Пример

Дано:

```py
x:
[[0 0 0]
 [0 0 1]
 [0 1 0]
 [0 1 1]
 [1 0 0]
 [1 0 1]
 [1 1 0]
 [1 1 1]]
y:
[1 1 0 0 1 1 1 0]
```

Вывод:

```py
Необученная модель
----------------------
predict:
[[0.5       ]
 [0.54452264]
 [0.5034757 ]
 [0.5208012 ]
 [0.4423405 ]
 [0.52544713]
 [0.4865361 ]
 [0.51709586]]
numpy:
[[0.5       ]
 [0.54452263]
 [0.50347573]
 [0.52080118]
 [0.4423405 ]
 [0.52544715]
 [0.48653605]
 [0.51709586]]
native:
[[0.5       ]
 [0.54452263]
 [0.50347573]
 [0.52080118]
 [0.4423405 ]
 [0.52544715]
 [0.48653605]
 [0.51709586]]

Обученная модель
----------------------
predict:
[[0.95918643]
 [0.98693186]
 [0.14112917]
 [0.03793827]
 [0.99014217]
 [0.995419  ]
 [0.83506286]
 [0.08731578]]
numpy:
[[0.95918638]
 [0.98693186]
 [0.14112915]
 [0.03793826]
 [0.99014209]
 [0.99541898]
 [0.8350628 ]
 [0.08731578]]
native:
[[0.95918638]
 [0.98693186]
 [0.14112915]
 [0.03793826]
 [0.99014209]
 [0.99541898]
 [0.8350628 ]
 [0.08731578]]
```

Из результатов видно, что точность предсказания высокая. А между результатами, полученными при симуляции и реальными результатами нет значительных различий.
